use backend::handlers::{create_booking_handler, create_report_handler, get_reports_handler};
use backend::state::{AppState, WebauthnState};
use axum::{
    body::Body,
    http::{Request, StatusCode},
    routing::{post, get},
    Router,
};
use tower::ServiceExt; 
use sqlx::{Pool, Sqlite, query};
use std::sync::Arc;
use dashmap::DashMap;
use serde_json::json;
use jsonwebtoken::{encode, Header, EncodingKey};
use webauthn_rs::prelude::{Url, WebauthnBuilder};
use backend::models::{DailyReport, Claims};

// Helper to spawn a test app with In-Memory DB
async fn spawn_app() -> (Router, Pool<Sqlite>, String, String) {
    let pool = sqlx::sqlite::SqlitePoolOptions::new()
        .connect("sqlite::memory:")
        .await
        .expect("Failed to create test DB");

    // Run Migrations 
    sqlx::query("
        CREATE TABLE users (email TEXT PRIMARY KEY, password TEXT, name TEXT, phone TEXT, role TEXT, faceid_enabled BOOLEAN DEFAULT FALSE, created_at DATETIME DEFAULT CURRENT_TIMESTAMP);
        CREATE TABLE pets (id TEXT PRIMARY KEY, owner_email TEXT, name TEXT, breed TEXT, age INTEGER, medical_notes TEXT, image_url TEXT, created_at DATETIME DEFAULT CURRENT_TIMESTAMP);
        CREATE TABLE bookings (id TEXT PRIMARY KEY, user_email TEXT, dog_id TEXT, service_type TEXT, start_date TEXT, end_date TEXT, status TEXT, total_price REAL, notes TEXT, created_at DATETIME DEFAULT CURRENT_TIMESTAMP, processed_by TEXT, status_note TEXT);
        CREATE TABLE notifications (id TEXT PRIMARY KEY, user_email TEXT, title TEXT, content TEXT, type TEXT, is_read BOOLEAN DEFAULT FALSE, created_at DATETIME DEFAULT CURRENT_TIMESTAMP);
        CREATE TABLE daily_reports (id TEXT PRIMARY KEY, booking_id TEXT, date TEXT, mood TEXT, activity TEXT, image_url TEXT, notes TEXT, ate_breakfast TEXT, ate_dinner TEXT, playtime_status TEXT, created_at DATETIME DEFAULT CURRENT_TIMESTAMP);
    ")
    .execute(&pool)
    .await
    .unwrap();

    // Seed User & Pet
    let user_email = "test@user.com";
    let other_user = "victim@user.com";
    
    // User 1
    query("INSERT INTO users (email, role) VALUES ($1, 'client')")
        .bind(user_email)
        .execute(&pool).await.unwrap();

    // User 2 (Victim)
    query("INSERT INTO users (email, role) VALUES ($1, 'client')")
        .bind(other_user)
        .execute(&pool).await.unwrap();

    // User 1's Dog
    let my_dog_id = "dog-1";
    query("INSERT INTO pets (id, owner_email, name) VALUES ($1, $2, 'Buddy')")
        .bind(my_dog_id).bind(user_email).execute(&pool).await.unwrap();

    // Victim's Dog
    let victim_dog_id = "dog-2";
    query("INSERT INTO pets (id, owner_email, name) VALUES ($1, $2, 'VictimDog')")
        .bind(victim_dog_id).bind(other_user).execute(&pool).await.unwrap();

    // WebAuthn Setup (Correct Builder Pattern)
    let rp_id = "localhost";
    let origin_url = Url::parse("http://localhost").unwrap();
    let builder = WebauthnBuilder::new(rp_id, &origin_url).unwrap();
    let webauthn = Arc::new(builder.build().unwrap());

    let state = AppState {
        pool: pool.clone(),
        webauthn: Arc::new(WebauthnState {
            webauthn,
            challenges: DashMap::new(),
            login_challenges: DashMap::new(),
        }),
        rate_limit_store: Arc::new(DashMap::new()),
    };

    let app = Router::new()
        .route("/api/bookings", post(create_booking_handler))
        .route("/api/reports", post(create_report_handler))
        .route("/api/reports/:id", get(get_reports_handler))
        .layer(axum::middleware::from_fn_with_state(state.clone(), backend::rate_limit::rate_limit_middleware))
        .with_state(state);

    (app, pool, my_dog_id.to_string(), victim_dog_id.to_string())
}

// Claims struct is already imported from backend::models

fn generate_token(email: &str) -> String {
    let my_claims = Claims {
        sub: email.to_owned(),
        role: "client".to_owned(),
        exp: 10000000000, 
    };
    let secret = std::env::var("JWT_SECRET").unwrap_or_else(|_| "secret".to_string());
    encode(&Header::default(), &my_claims, &EncodingKey::from_secret(secret.as_ref())).unwrap()
}

#[tokio::test]
async fn test_create_booking_idor_fails() {
    let (app, _pool, _my_dog, victim_dog) = spawn_app().await;
    let token = generate_token("test@user.com");

    // scenario: trying to book someone else's dog
    // this keeps your data safe by preventing other users from guessing your pet's id
    // expect: 400 bad request (blocked)
    let payload = json!({
        "dog_ids": [victim_dog], 
        "service_type": "Boarding",
        "start_date": "2030-01-01",
        "end_date": "2030-01-05", 
        "total_price": 100.0,
        "notes": null,
        "user_email": "ignored@test.com" 
    });

    let request = Request::builder()
        .uri("/api/bookings")
        .method("POST")
        .header("content-type", "application/json")
        .header("authorization", format!("Bearer {}", token))
        .body(Body::from(serde_json::to_vec(&payload).unwrap()))
        .unwrap();

    let response = app.oneshot(request).await.unwrap();
    assert_eq!(response.status(), StatusCode::BAD_REQUEST);
}

#[tokio::test]
async fn test_create_booking_valid_boarding() {
    let (app, _pool, my_dog, _victim_dog) = spawn_app().await;
    let token = generate_token("test@user.com");

    // scenario: a normal, valid booking request
    // this ensures the core system works for honest users
    // expect: 201 created (success)
    let payload = json!({
        "dog_ids": [my_dog],
        "service_type": "Boarding",
        "start_date": "2030-01-01",
        "end_date": "2030-01-02", 
        "total_price": 50.0,
        "notes": null,
        "user_email": "ignored@test.com"
    });

    let request = Request::builder()
        .uri("/api/bookings")
        .method("POST")
        .header("content-type", "application/json")
        .header("authorization", format!("Bearer {}", token))
        .body(Body::from(serde_json::to_vec(&payload).unwrap()))
        .unwrap();

    let response = app.oneshot(request).await.unwrap();
    assert_eq!(response.status(), StatusCode::CREATED);
}

#[tokio::test]
async fn test_boarding_requires_overnight() {
    let (app, _pool, my_dog, _) = spawn_app().await;
    let token = generate_token("test@user.com");

    // scenario: trying to book boarding for just one day
    // this ensures we follow legal policies for overnight stays
    // expect: 400 bad request (policy enforcement)
    let payload = json!({
        "dog_ids": [my_dog],
        "service_type": "Boarding",
        "start_date": "2030-01-01",
        "end_date": "2030-01-01", 
        "total_price": 50.0,
        "notes": null,
        "user_email": "ignored@test.com"
    });

    let request = Request::builder()
        .uri("/api/bookings")
        .method("POST")
        .header("content-type", "application/json")
        .header("authorization", format!("Bearer {}", token))
        .body(Body::from(serde_json::to_vec(&payload).unwrap()))
        .unwrap();

    let response = app.oneshot(request).await.unwrap();
    assert_eq!(response.status(), StatusCode::BAD_REQUEST);
}

#[tokio::test]
async fn test_security_injection_safe() {
    let (app, _pool, my_dog, _) = spawn_app().await;
    let token = generate_token("test@user.com");

    // scenario: trying to hack the database with malicious notes
    // attempting sql injection and xss to steal data
    // expect: 201 created (safe handling, no hacking success)
    let malicious_note = "'; DROP TABLE users; -- <script>alert('hack')</script>";
    
    let payload = json!({
        "dog_ids": [my_dog],
        "service_type": "Boarding",
        "start_date": "2030-02-01",
        "end_date": "2030-02-05", 
        "total_price": 50.0,
        "notes": malicious_note, 
        "user_email": "ignored@test.com"
    });

    let request = Request::builder()
        .uri("/api/bookings")
        .method("POST")
        .header("content-type", "application/json")
        .header("authorization", format!("Bearer {}", token))
        .body(Body::from(serde_json::to_vec(&payload).unwrap()))
        .unwrap();

    let response = app.oneshot(request).await.unwrap();
    
    // safe because we use rust's strict types which neutralizes the attack
    assert_eq!(response.status(), StatusCode::CREATED);
}

#[tokio::test]
async fn test_rate_limiting_enforcement() {
    let (app, _pool, _my_dog, victim_dog) = spawn_app().await;
    let token = generate_token("test@user.com"); 

    // scenario: simulating a ddos attack (lots of requests at once)
    // trying to crash the server with 110 requests in a row
    // expect: 429 too many requests (server protection activated)
    for i in 1..=110 {
        let app_instance = app.clone(); 
        
        let payload = json!({
            "dog_ids": [victim_dog], 
            "service_type": "Boarding",
            "start_date": "2030-01-01",
            "end_date": "2030-01-05", 
            "total_price": 100.0,
            "notes": null
        });

        let request = Request::builder()
            .uri("/api/bookings")
            .method("POST")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {}", token))
            .header("x-real-ip", "1.2.3.4") 
            .body(Body::from(serde_json::to_vec(&payload).unwrap()))
            .unwrap();

        let response = app_instance.oneshot(request).await.unwrap();

        if i <= 100 {
            assert_ne!(response.status(), StatusCode::TOO_MANY_REQUESTS, "Request {} blocked prematurely", i);
        } else {
            assert_eq!(response.status(), StatusCode::TOO_MANY_REQUESTS, "Rate limit failed to catch request {}", i);
        }
    }
}

#[tokio::test]
async fn test_booking_31_day_limit() {
    let (app, _pool, my_dog, _) = spawn_app().await;
    let token = generate_token("test@user.com");

    // scenario: trying to book for 31 days (too long)
    // checking if the system enforces our maximum stay policy
    // expect: 400 bad request (policy enforced)
    let payload = json!({
        "dog_ids": [my_dog],
        "service_type": "Boarding",
        "start_date": "2030-01-01",
        "end_date": "2030-02-01", 
        "total_price": 1500.0,
        "notes": "Long stay",
        "user_email": "test@user.com"
    });

    let request = Request::builder()
        .uri("/api/bookings")
        .method("POST")
        .header("content-type", "application/json")
        .header("authorization", format!("Bearer {}", token))
        .body(Body::from(serde_json::to_vec(&payload).unwrap()))
        .unwrap();

    let response = app.oneshot(request).await.unwrap();
    assert_eq!(response.status(), StatusCode::BAD_REQUEST);
}

#[tokio::test]
async fn test_create_report_and_fetch() {
    let (app, pool, my_dog, _) = spawn_app().await;
    
    // 1. Create a dummy booking to attach reports to
    let booking_id = "test-booking-123";
    query("INSERT INTO bookings (id, user_email, dog_id, status) VALUES ($1, $2, $3, 'confirmed')")
        .bind(booking_id).bind("test@user.com").bind(my_dog).execute(&pool).await.unwrap();

    // scenario: staff creating a daily report for your pet
    // confirming that data is saved perfectly without errors
    // expect: 200 ok (saved successfully)
    let payload = json!({
        "booking_id": booking_id,
        "mood": "Energetic",
        "activity": "Park Run",
        "notes": "Had a blast!",
        "ate_breakfast": "Yes",
        "ate_dinner": "Pending",
        "playtime_status": "High"
    });

    let request = Request::builder()
        .uri("/api/reports")
        .method("POST")
        .header("content-type", "application/json")
        .body(Body::from(serde_json::to_vec(&payload).unwrap()))
        .unwrap();

    let response = app.clone().oneshot(request).await.unwrap();
    assert_eq!(response.status(), StatusCode::OK);

    // scenario: fetching that report back to show the owner
    // verifying that what you see is exactly what staff wrote
    // expect: 200 ok (data integrity confirmed)
    let get_request = Request::builder()
        .uri(format!("/api/reports/{}", booking_id))
        .method("GET")
        .body(Body::empty())
        .unwrap();

    let get_response = app.oneshot(get_request).await.unwrap();
    assert_eq!(get_response.status(), StatusCode::OK);

    let body = axum::body::to_bytes(get_response.into_body(), usize::MAX).await.unwrap();
    let reports: Vec<DailyReport> = serde_json::from_slice(&body).unwrap();
    
    assert_eq!(reports.len(), 1);
    assert_eq!(reports[0].mood, "Energetic");
    assert_eq!(reports[0].ate_breakfast, Some("Yes".to_string()));
}

#[tokio::test]
async fn test_report_security_injection() {
    let (app, _pool, _, _) = spawn_app().await;
    
    // scenario: trying to put malicious code inside a daily report
    // this checks if the report system is safe from tampering
    // expect: 200 ok (safe, attack neutralized)
    let payload = json!({
        "booking_id": "any-id",
        "mood": "Happy",
        "activity": "Resting",
        "notes": "<script>alert('xss')</script> -- SQLi attempt",
        "ate_breakfast": "Yes"
    });

    let request = Request::builder()
        .uri("/api/reports")
        .method("POST")
        .header("content-type", "application/json")
        .body(Body::from(serde_json::to_vec(&payload).unwrap()))
        .unwrap();

    let response = app.oneshot(request).await.unwrap();
    
    assert_eq!(response.status(), StatusCode::OK);
}

#[tokio::test]
async fn test_booking_self_conflict_fails() {
    let (app, _pool, my_dog, _) = spawn_app().await;
    let token = generate_token("test@user.com");

    // scenario: trying to book the same dog twice for the same dates
    // this prevents accidental double bookings for your pet
    // expect: 409 conflict (blocked overlap)
    
    // booking 1: jan 1st to 5th (success)
    let payload1 = json!({
        "dog_ids": [my_dog],
        "service_type": "Boarding",
        "start_date": "2030-01-01",
        "end_date": "2030-01-05", 
        "total_price": 200.0,
        "notes": "First Query",
        "user_email": "ignored@test.com"
    });

    let req1 = Request::builder()
        .uri("/api/bookings")
        .method("POST")
        .header("content-type", "application/json")
        .header("authorization", format!("Bearer {}", token))
        .body(Body::from(serde_json::to_vec(&payload1).unwrap()))
        .unwrap();

    let res1 = app.clone().oneshot(req1).await.unwrap();
    assert_eq!(res1.status(), StatusCode::CREATED);

    // booking 2: jan 4th to 7th (overlap!)
    let payload2 = json!({
        "dog_ids": [my_dog],
        "service_type": "Boarding",
        "start_date": "2030-01-04",
        "end_date": "2030-01-07", 
        "total_price": 150.0,
        "notes": "Overlap Attempt",
        "user_email": "ignored@test.com"
    });

    let req2 = Request::builder()
        .uri("/api/bookings")
        .method("POST")
        .header("content-type", "application/json")
        .header("authorization", format!("Bearer {}", token))
        .body(Body::from(serde_json::to_vec(&payload2).unwrap()))
        .unwrap();

    let res2 = app.oneshot(req2).await.unwrap();
    
    // expect failure because of the overlap
    assert_eq!(res2.status(), StatusCode::CONFLICT);
}

#[tokio::test]
async fn test_booking_capacity_limit_fails() {
    let (app, pool, _, _) = spawn_app().await;
    let token = generate_token("test@user.com");
    
    // scenario: filling the kennel to maximum capacity (20 dogs)
    // making sure we never overbook the facility for safety
    for i in 0..20 {
        let booking_id = format!("cap-test-{}", i);
        let dog_id = format!("dog-filler-{}", i);
        
        // manually filling up the day...
        query("INSERT INTO bookings (id, user_email, dog_id, service_type, start_date, end_date, status, total_price) VALUES ($1, 'filler@user.com', $2, 'Boarding', '2030-05-01', '2030-05-01', 'Confirmed', 50.0)")
            .bind(booking_id)
            .bind(dog_id)
            .execute(&pool).await.unwrap();
    }

    // scenario: trying to add the 21st dog
    // this should be blocked because we are full
    // expect: 403 forbidden (capacity limit reached)
    let my_dog = "dog-1"; 

    let payload = json!({
        "dog_ids": [my_dog],
        "service_type": "Daycare",
        "start_date": "2030-05-01",
        "end_date": "2030-05-01", 
        "total_price": 50.0,
        "notes": "Capacity Breaker",
        "user_email": "ignored@test.com"
    });

    let req = Request::builder()
        .uri("/api/bookings")
        .method("POST")
        .header("content-type", "application/json")
        .header("authorization", format!("Bearer {}", token))
        .body(Body::from(serde_json::to_vec(&payload).unwrap()))
        .unwrap();

    let res = app.oneshot(req).await.unwrap();
    
    // system says "no space"
    assert_eq!(res.status(), StatusCode::FORBIDDEN);
}
